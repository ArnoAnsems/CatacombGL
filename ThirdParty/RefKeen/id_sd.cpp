/* Catacomb 3-D Source Code
 * Copyright (C) 1993-2014 Flat Rock Software
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


#include "id_sd.h"
#include "be_st.h"

#define	SDL_SoundFinished()	{SoundNumber = SoundPriority = 0;}

// Macros for AdLib stuff
#define	selreg(n)	outportb(0x388,n)
#define	writereg(n)	outportb(0x389,n)
#define	readstat()	inportb(0x388)

//	Global variables
	bool		SoundSourcePresent,SoundBlasterPresent,AdLibPresent;
	SDMode		SoundMode;
	// NEVER accessed directly now - done from backend via functions
	//id0_longword_t	TimeCount;
	uint16_t		HackCount;
	PCSound		**pcSoundTable;
    AdlibSound ** AdlibSoundTable;
	//id0_word_t		*SoundTable;	// Really * seg *SoundTable, but that don't work
	bool		ssIsTandy;
	uint16_t		ssPort = 2;

//	Internal variables
static	bool			SD_Started;
static	void			(*SoundUserHook)(void);
static	uint16_t			SoundNumber,SoundPriority;
//static	void interrupt	(*t0OldService)(void);
//static	id0_word_t			t0CountTable[] = {8,8,8,8,40,40};
//static	id0_long_t			LocalTime;

//	PC Sound variables
static	uint8_t			pcLastSample, *pcSound;
static	uint32_t		pcLengthLeft;
static	uint16_t			pcSoundLookup[255];

//	AdLib variables
static	bool			alNoCheck;
static	uint8_t			*alSound;
static	uint16_t			alBlock;
static	uint32_t		alLengthLeft;
static	uint32_t		alTimeCount;
static	AdlibSound*		alZeroInst = new AdlibSound();

// This table maps channel numbers to carrier and modulator op cells
static	uint8_t			carriers[9] =  { 3, 4, 5,11,12,13,19,20,21},
						modifiers[9] = { 0, 1, 2, 8, 9,10,16,17,18};

//	Sequencer variables

static	uint16_t			alFXReg;

//	Internal routines

///////////////////////////////////////////////////////////////////////////
//
//	SDL_SetTimer0() - Sets system timer 0 to the specified speed
//
///////////////////////////////////////////////////////////////////////////
//#pragma	argsused
static void
SDL_SetTimer0(uint16_t speed)
{
	BE_ST_SetTimer(speed); // HACK for different timing with music on

}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_SetIntsPerSec() - Uses SDL_SetTimer0() to set the number of
//		interrupts generated by system timer 0 per second
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_SetIntsPerSec(uint16_t ints)
{
	SDL_SetTimer0(1192030 / ints);
}



//
//	PC Sound code
//

///////////////////////////////////////////////////////////////////////////
//
//	SDL_PCPlaySound() - Plays the specified sound on the PC speaker
//
///////////////////////////////////////////////////////////////////////////
#ifdef	_MUSE_
void
#else
static void
#endif
SDL_PCPlaySound(PCSound *sound)
{
	BE_ST_LockAudioRecursively();

	pcLastSample = -1;
	pcLengthLeft = sound->GetLength();
	pcSound = sound->GetData();

    SoundPriority = sound->GetPriority();

	BE_ST_UnlockAudioRecursively();
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_PCStopSound() - Stops the current sound playing on the PC Speaker
//
///////////////////////////////////////////////////////////////////////////

static void
SDL_PCStopSound(void)
{
	BE_ST_LockAudioRecursively();

	pcSound = 0;
	BE_ST_PCSpeakerOff();

	BE_ST_UnlockAudioRecursively();
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_PCService() - Handles playing the next sample in a PC sound
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_PCService(void)
{
	uint8_t	s;
	uint16_t t;

	if (pcSound)
	{
		s = *pcSound++;
		if (s != pcLastSample)
		{
			BE_ST_LockAudioRecursively();

			pcLastSample = s;
			if (s)					// We have a frequency!
			{
				t = pcSoundLookup[s];
				BE_ST_PCSpeakerOn(t);

			}
			else					// Time for some silence
			{
				BE_ST_PCSpeakerOff();
			}

			BE_ST_UnlockAudioRecursively();
		}

		if (!(--pcLengthLeft))
		{
			SDL_PCStopSound();
			SDL_SoundFinished();
		}
	}
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_ShutPC() - Turns off the pc speaker
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_ShutPC(void)
{
	BE_ST_LockAudioRecursively();

	pcSound = 0;

	BE_ST_PCSpeakerOff();

	BE_ST_UnlockAudioRecursively();
}

// 	AdLib Code

///////////////////////////////////////////////////////////////////////////
//
//	alOut(n,b) - Puts b in AdLib card register n
//
///////////////////////////////////////////////////////////////////////////
void
alOut(uint8_t n,uint8_t b)
{
    BE_ST_OPL2Write(n, b);
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_ALStopSound() - Turns off any sound effects playing through the
//		AdLib card
//
///////////////////////////////////////////////////////////////////////////

static void
SDL_ALStopSound(void)
{
	BE_ST_LockAudioRecursively();

	alSound = 0;
	alOut(alFreqH + 0,0);

	BE_ST_UnlockAudioRecursively();
}

static void
SDL_AlSetFXInst(AdlibSound *inst)
{
	uint8_t		c,m;

	m = modifiers[0];
	c = carriers[0];
	alOut(m + alChar,inst->GetmChar());
	alOut(m + alScale,inst->GetmScale());
	alOut(m + alAttack,inst->GetmAttack());
	alOut(m + alSus,inst->GetmSus());
	alOut(m + alWave,inst->GetmWave());
	alOut(c + alChar,inst->GetcChar());
	alOut(c + alScale,inst->GetcScale());
	alOut(c + alAttack,inst->GetcAttack());
	alOut(c + alSus,inst->GetcSus());
	alOut(c + alWave,inst->GetcWave());
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_ALPlaySound() - Plays the specified sound on the AdLib card
//
///////////////////////////////////////////////////////////////////////////
void
SDL_ALPlaySound(AdlibSound *sound)
{
	SDL_ALStopSound();

	BE_ST_LockAudioRecursively();
//asm	pushf
//asm	cli

	alLengthLeft = sound->GetLength();
	alSound = sound->GetData();
	alBlock = ((sound->GetOctave() & 7) << 2) | 0x20;

    SoundPriority = sound->GetPriority();

	if (!(sound->GetmSus() | sound->GetcSus()))
	{
		BE_ST_UnlockAudioRecursively();
		//Quit("SDL_ALPlaySound() - Bad instrument");
	}

	SDL_AlSetFXInst(sound);

	BE_ST_UnlockAudioRecursively();
}

///////////////////////////////////////////////////////////////////////////
//
// 	SDL_ALSoundService() - Plays the next sample out through the AdLib card
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_ALSoundService(void)
{
	uint8_t	s;

	if (alSound)
	{
		s = *alSound++;
		if (!s)
			alOut(alFreqH + 0,0);
		else
		{
			alOut(alFreqL + 0,s);
			alOut(alFreqH + 0,(uint8_t)alBlock);
		}

		if (!(--alLengthLeft))
		{
			alSound = 0;
			alOut(alFreqH + 0,0);
			SDL_SoundFinished();
		}
	}
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_ShutAL() - Shuts down the AdLib card for sound effects
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_ShutAL(void)
{
	BE_ST_LockAudioRecursively();
//asm	pushf
//asm	cli

	alOut(alEffects,0);
	alOut(alFreqH + 0,0);
	SDL_AlSetFXInst(alZeroInst);
	alSound = 0;

	BE_ST_UnlockAudioRecursively();
//asm	popf
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_CleanAL() - Totally shuts down the AdLib card
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_CleanAL(void)
{
	uint8_t	i;

	BE_ST_LockAudioRecursively();

	alOut(alEffects,0);
	for (i = 1;i < 0xf5;i++)
		alOut(i,0);

	BE_ST_UnlockAudioRecursively();
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_StartAL() - Starts up the AdLib card for sound effects
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_StartAL(void)
{
	alFXReg = 0;
	alOut(alEffects, (uint8_t)alFXReg);
	SDL_AlSetFXInst(alZeroInst);
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_DetectAdLib() - Determines if there's an AdLib (or SoundBlaster
//		emulating an AdLib) present
//
///////////////////////////////////////////////////////////////////////////
static bool
SDL_DetectAdLib(void)
{
	// REFKEEN - If there's no emulated OPL chip, just return false
	if (!BE_ST_IsEmulatedOPLChipReady())
	{
		return false;
	}

	alOut(4,0x60);	// Reset T1 & T2
	alOut(4,0x80);	// Reset IRQ
	//status1 = readstat();
	alOut(2,0xff);	// Set timer 1
	alOut(4,0x21);	// Start timer 1

	// We ALWAYS return true here, but maybe it's good
	// to send some commands to the emulated OPL chip

	// TODO (REFKEEN): Anyway to handle this delay (if at all)?
	//SDL_Delay(TimerDelay100);

	//status2 = readstat();
	alOut(4,0x60);
	alOut(4,0x80);

	//if (((status1 & 0xe0) == 0x00) && ((status2 & 0xe0) == 0xc0))
	{
		for (uint8_t i = 1;i <= 0xf5;i++)	// Zero all the registers
			alOut(i,0);

		alOut(1,0x20);	// Set WSE=1
		alOut(8,0);		// Set CSM=0 & SEL=0

		return(true);
	}
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_t0Service() - My timer 0 ISR which handles the different timings and
//		dispatches to whatever other routines are appropriate
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_t0Service(void)
{
static	int16_t	count = 1;

	HackCount++;

	{
		if (!(++count & 1))
		{
			if (SoundUserHook)
				SoundUserHook();
		}
		switch (SoundMode)
		{
		case sdm_PC:
			SDL_PCService();
			break;
		case sdm_AdLib:
			SDL_ALSoundService();
			break;
		}
	}
}

////////////////////////////////////////////////////////////////////////////
//
//	SDL_ShutDevice() - turns off whatever device was being used for sound fx
//
////////////////////////////////////////////////////////////////////////////
static void
SDL_ShutDevice(void)
{
	switch (SoundMode)
	{
	case sdm_PC:
		SDL_ShutPC();
		break;
	case sdm_AdLib:
		SDL_ShutAL();
		break;
	}
	SoundMode = sdm_Off;
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_CleanDevice() - totally shuts down all sound devices
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_CleanDevice(void)
{
	if ((SoundMode == sdm_AdLib))
		SDL_CleanAL();
}

///////////////////////////////////////////////////////////////////////////
//
//	SDL_StartDevice() - turns on whatever device is to be used for sound fx
//
///////////////////////////////////////////////////////////////////////////
static void
SDL_StartDevice(void)
{
	switch (SoundMode)
	{
	case sdm_AdLib:
		SDL_StartAL();
		break;
	}
	SoundNumber = SoundPriority = 0;
}

static void
SDL_SetTimerSpeed(void)
{
	int16_t	rate = TickBase * 2;
	SDL_SetIntsPerSec(rate);
}

//	Public routines

///////////////////////////////////////////////////////////////////////////
//
//	SD_SetSoundMode() - Sets which sound hardware to use for sound effects
//
///////////////////////////////////////////////////////////////////////////
bool
SD_SetSoundMode(SDMode mode)
{
	SD_StopSound();

	if (mode != SoundMode)
	{
		SDL_ShutDevice();
		SoundMode = mode;
		SDL_StartDevice();
	}

	SDL_SetTimerSpeed();

	return true;
}

SDMode
SD_GetSoundMode()
{
    return SoundMode;
}



///////////////////////////////////////////////////////////////////////////
//
//	SD_Startup() - starts up the Sound Mgr
//		Detects all additional sound hardware and installs my ISR
//
///////////////////////////////////////////////////////////////////////////
void
SD_Startup(void)
{
	if (SD_Started)
		return;

	ssIsTandy = false;

	SoundUserHook = 0;

	//t0OldService = getvect(8);	// Get old timer 0 ISR

	/*** (REFKEEN) UNUSED ***/
	//SDL_InitDelay();			// SDL_InitDelay() uses t0OldService

    BE_ST_StartAudioAndTimerInt(&SDL_t0Service);
	//setvect(8,SDL_t0Service);	// Set to my timer 0 ISR
	/*LocalTime = TimeCount =*/ alTimeCount = 0;

	SD_SetSoundMode(sdm_Off);

    AdLibPresent = SDL_DetectAdLib();

	for (uint16_t i = 0;i < 255;i++)
		pcSoundLookup[i] = i * 60;

	SD_Started = true;
}

///////////////////////////////////////////////////////////////////////////
//
//	SD_Default() - Sets up the default behaviour for the Sound Mgr whether
//		the config file was present or not.
//
///////////////////////////////////////////////////////////////////////////
void
SD_Default(bool gotit,SDMode sd,SMMode sm)
{
	bool	gotsd,gotsm;

	gotsd = gotsm = gotit;

	if (gotsd)	// Make sure requested sound hardware is available
	{
		switch (sd)
		{
		case sdm_AdLib:
			gotsd = AdLibPresent;
			break;
		}
	}
	if (!gotsd)
	{
		if (AdLibPresent)
			sd = sdm_AdLib;
		else
			sd = sdm_PC;
	}
	if (sd != SoundMode)
		SD_SetSoundMode(sd);
}

///////////////////////////////////////////////////////////////////////////
//
//	SD_Shutdown() - shuts down the Sound Mgr
//		Removes sound ISR and turns off whatever sound hardware was active
//
///////////////////////////////////////////////////////////////////////////
void
SD_Shutdown(void)
{
	if (!SD_Started)
		return;

    BE_ST_StopAudioAndTimerInt();

	SDL_ShutDevice();
	SDL_CleanDevice();

	BE_ST_LockAudioRecursively();

	SDL_SetTimer0(0);

// Do NOT call this here - A deadlock is a possibility (via recursive lock)
//	BE_ST_StopAudioSDService(void);
//	setvect(8,t0OldService);

	BE_ST_UnlockAudioRecursively();

	SD_Started = false;
}

///////////////////////////////////////////////////////////////////////////
//
//	SD_SetUserHook() - sets the routine that the Sound Mgr calls every 1/70th
//		of a second from its timer 0 ISR
//
///////////////////////////////////////////////////////////////////////////
void
SD_SetUserHook(void (* hook)(void))
{
	SoundUserHook = hook;
}


///////////////////////////////////////////////////////////////////////////
//
//	SD_SoundPlaying() - returns the sound number that's playing, or 0 if
//		no sound is playing
//
///////////////////////////////////////////////////////////////////////////
bool
SD_SoundPlaying(void)
{
	bool	result = false;

	switch (SoundMode)
	{
	case sdm_PC:
		result = pcSound? true : false;
		break;
	case sdm_AdLib:
		result = alSound? true : false;
		break;
	}

    return result;
}

///////////////////////////////////////////////////////////////////////////
//
//	SD_StopSound() - if a sound is playing, stops it
//
///////////////////////////////////////////////////////////////////////////
void
SD_StopSound(void)
{
	switch (SoundMode)
	{
	case sdm_PC:
		SDL_PCStopSound();
		break;
	case sdm_AdLib:
		SDL_ALStopSound();
		break;
	}

	SDL_SoundFinished();
}

///////////////////////////////////////////////////////////////////////////
//
//	SD_WaitSoundDone() - waits until the current sound is done playing
//
///////////////////////////////////////////////////////////////////////////
void
SD_WaitSoundDone(void)
{
	while (SD_SoundPlaying())
	{
		BE_ST_ShortSleep();
	}
}


// Replacements for direct accesses to TimeCount variable
// (should be instantiated here even if inline, as of C99)
//id0_longword_t SD_GetTimeCount(void);
//void SD_SetTimeCount(id0_longword_t newcount);
